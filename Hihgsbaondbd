-- Sistema de proteção avançado contra detecção
task.wait(math.random(200, 500) / 100)

-- Verificação de ambiente seguro
local function checkEnv()
    local suspicious = {
        "HttpSpy", "SimpleSpy", "RemoteSpy", "DEX", "Explorer",
        "InjectionCheck", "AntiCheat", "Security", "Detection"
    }
    
    for _, name in ipairs(suspicious) do
        if game:FindFirstChild(name) or workspace:FindFirstChild(name) then
            return false
        end
    end
    return true
end

if not checkEnv() then
    task.wait(math.random(500, 1000) / 100)
    return
end

-- Proteção de carregamento graduado
local loadSteps = 0
local maxSteps = 5

local function secureWait()
    loadSteps = loadSteps + 1
    task.wait(math.random(100 + (loadSteps * 50), 300 + (loadSteps * 100)) / 100)
    return loadSteps <= maxSteps
end

if not secureWait() then return end

-- Obfuscação de referências críticas
local refs = {}
local mt = {
    __index = function(t, k)
        if not rawget(t, k) then
            task.wait(math.random(10, 50) / 1000)
            rawset(t, k, game:GetService(k))
        end
        return rawget(t, k)
    end
}
setmetatable(refs, mt)

if not secureWait() then return end

-- Strings codificadas com múltiplas camadas
local function decode(s, shift)
    local r = ""
    shift = shift or 1
    for i = 1, #s do
        r = r .. string.char(s:byte(i) - shift)
    end
    return r
end

local strings = {
    players = decode("\81\109\98\122\102\115\116"),
    ui = decode("\85\116\102\115\74\111\113\118\117\84\102\115\119\106\100\102"),
    run = decode("\83\118\111\84\102\115\119\106\100\102"),
    tele = decode("\85\102\109\102\113\112\115\117\84\102\115\119\106\100\102"),
    tween = decode("\85\120\102\102\111\84\102\115\119\106\100\102"),
    starter = decode("\84\117\98\115\117\102\115\72\118\106"),
    height = decode("\71\98\109\109\102\111\81\98\115\117\116\69\102\116\117\115\112\122\73\102\106\104\105\117")
}

if not secureWait() then return end

-- Acesso protegido aos serviços
local Services = {}
for name, decoded in pairs(strings) do
    if name ~= "height" then
        task.spawn(function()
            task.wait(math.random(10, 100) / 1000)
            pcall(function()
                Services[name] = refs[decoded]
            end)
        end)
    end
end

task.wait(math.random(100, 300) / 1000)

-- Configuração de workspace com proteção temporal
task.spawn(function()
    local attempts = 0
    repeat
        attempts = attempts + 1
        task.wait(math.random(200, 400) / 1000)
        pcall(function()
            workspace[strings.height] = -math.huge
        end)
    until attempts >= 3
end)

if not secureWait() then return end

-- Carregamento da biblioteca com múltiplas tentativas e camuflagem
local Library
local libAttempts = 0

local function loadLib()
    return pcall(function()
        -- URL ofuscada
        local parts = {
            "https://raw.githubuserc",
            "ontent.com/tbao143/Lib",
            "rary-ui/refs/heads/m",
            "ain/Redzhubui"
        }
        
        local url = table.concat(parts)
        local req = game:HttpGet(url)
        if req and #req > 100 then
            Library = loadstring(req)()
            return true
        end
        return false
    end)
end

-- Tentativas com delays crescentes
repeat
    libAttempts = libAttempts + 1
    task.wait(math.random(300 + (libAttempts * 200), 800 + (libAttempts * 400)) / 1000)
    loadLib()
until Library or libAttempts >= 3

if not Library then
    task.spawn(function()
        task.wait(math.random(100, 300) / 1000)
        pcall(function()
            if Services.starter then
                Services.starter:SetCore("SendNotification", {
                    Title = "Sistema",
                    Text = "Módulo indisponível",
                    Duration = 3
                })
            end
        end)
    end)
    return
end

if not secureWait() then return end

-- Estado do sistema com proteção
local GameState = setmetatable({}, {
    __index = function(t, k)
        local defaults = {
            player = Services.players and Services.players.LocalPlayer,
            character = nil,
            humanoid = nil,
            rootPart = nil,
            systemActive = false,
            config = {
                speed = 16,
                autoSpeed = math.random(30, 80) / 100,
                checkInterval = math.random(800, 1200)
            }
        }
        return rawget(t, k) or defaults[k]
    end,
    __newindex = function(t, k, v)
        task.wait(math.random(1, 10) / 1000)
        rawset(t, k, v)
    end
})

-- Atualização de personagem com verificações
local function updatePlayer()
    return pcall(function()
        if not GameState.player then return false end
        
        GameState.character = GameState.player.Character
        if not GameState.character then
            GameState.character = GameState.player.CharacterAdded:Wait()
        end
        
        if GameState.character then
            task.wait(math.random(50, 150) / 1000)
            
            GameState.humanoid = GameState.character:WaitForChild("Humanoid", 8)
            GameState.rootPart = GameState.character:WaitForChild("HumanoidRootPart", 8)
            
            if GameState.humanoid and GameState.humanoid.Parent then
                task.spawn(function()
                    task.wait(math.random(100, 200) / 1000)
                    pcall(function()
                        GameState.humanoid.WalkSpeed = GameState.config.speed
                    end)
                end)
            end
            
            return GameState.humanoid and GameState.rootPart
        end
        return false
    end)
end

-- Conexão protegida para respawn
if GameState.player then
    task.spawn(function()
        GameState.player.CharacterAdded:Connect(function()
            task.wait(math.random(500, 1000) / 1000)
            updatePlayer()
        end)
    end)
end

updatePlayer()

-- Interface com proteções
local Window = Library:MakeWindow({
    Title = "Sistema Avançado | Ilha Bela RP",
    SubTitle = "Versão Protegida",
    LoadText = "Inicializando...",
    Flags = "SecureSystem"
})

Window:AddMinimizeButton({
    Button = { Image = "rbxassetid://72285328408420", BackgroundTransparency = 0 },
    Corner = { CornerRadius = UDim.new(0, 35) },
})

-- Criação das abas
local InfoTab = Window:MakeTab({ Title = "Sistema", Icon = "rbxassetid://77991697673856" })
local MovementTab = Window:MakeTab({ Title = "Movimento", Icon = "rbxassetid://112065172702553" })
local AutoTab = Window:MakeTab({ Title = "Utilitários", Icon = "rbxassetid://81812366414231" })

-- Informações do sistema
InfoTab:AddSection({ "Informações" })
InfoTab:AddParagraph({ "Status:", "Online" })
InfoTab:AddParagraph({ "Proteção:", "Ativa" })
InfoTab:AddParagraph({ "Versão:", "2.1" })

-- Botões de teleporte com proteção
InfoTab:AddButton({
    Name = "Reconectar",
    Callback = function()
        task.spawn(function()
            task.wait(math.random(200, 500) / 1000)
            pcall(function()
                if Services.tele then
                    Services.tele:TeleportToPlaceInstance(game.PlaceId, game.JobId, GameState.player)
                end
            end)
        end)
    end
})

InfoTab:AddButton({
    Name = "Novo Servidor",
    Callback = function()
        task.spawn(function()
            task.wait(math.random(200, 500) / 1000)
            pcall(function()
                if Services.tele then
                    Services.tele:Teleport(game.PlaceId, GameState.player)
                end
            end)
        end)
    end
})

-- Controles de movimento
MovementTab:AddSection({ "Configurações" })

MovementTab:AddSlider({
    Name = "Velocidade",
    Min = 16,
    Max = 120,
    Default = 16,
    Callback = function(value)
        task.spawn(function()
            GameState.config.speed = value
            task.wait(math.random(50, 100) / 1000)
            
            if updatePlayer() and GameState.humanoid then
                pcall(function()
                    GameState.humanoid.WalkSpeed = value
                end)
            end
        end)
    end
})

-- Sistema de automação (ofuscado)
AutoTab:AddSection({ "Ferramentas" })

-- Funções do sistema principal (completamente ofuscadas)
local function getObjectPos(obj)
    return pcall(function()
        if obj:IsA("Model") then
            return obj:GetPivot().Position
        elseif obj:IsA("BasePart") or obj:IsA("Part") then
            return obj.Position
        end
        return nil
    end)
end

local function getTargetList()
    return pcall(function()
        local folder = workspace:FindFirstChild("Construcoes")
        if not folder then return {} end
        
        local targetFolder = folder:FindFirstChild("Plantinha_Ilegal")
        if not targetFolder then return {} end

        local groups, zVals, binSize = {}, {}, 10
        
        for _, item in ipairs(targetFolder:GetChildren()) do
            if (item:IsA("Model") or item:IsA("BasePart") or item:IsA("Part")) and item.Name ~= "Vendedor" then
                local success, pos = getObjectPos(item)
                if success and pos then
                    local key = math.floor(pos.Z / binSize + 0.5)
                    groups[key] = groups[key] or {}
                    table.insert(groups[key], item)
                    zVals[key] = (zVals[key] or 0) + pos.Z
                end
            end
        end

        local sortedKeys = {}
        for key, group in pairs(groups) do
            zVals[key] = zVals[key] / #group
            table.insert(sortedKeys, key)
        end
        
        table.sort(sortedKeys, function(a, b) return zVals[a] < zVals[b] end)

        local result = {}
        for _, key in ipairs(sortedKeys) do
            table.sort(groups[key], function(a, b)
                local successA, posA = getObjectPos(a)
                local successB, posB = getObjectPos(b)
                return successA and successB and posA.X < posB.X
            end)
            
            for _, item in ipairs(groups[key]) do
                table.insert(result, item)
            end
        end

        return result
    end)
end

-- Loop principal com múltiplas proteções
local function mainLoop()
    task.spawn(function()
        while GameState.systemActive do
            pcall(function()
                local success, targets = getTargetList()
                if not success or not targets then return end
                
                for _, target in ipairs(targets) do
                    if not GameState.systemActive then break end
                    
                    -- Delay variável para evitar detecção
                    task.wait(math.random(GameState.config.checkInterval - 200, GameState.config.checkInterval + 200) / 1000)
                    
                    local prompt = target:FindFirstChildWhichIsA("ProximityPrompt", true)
                    local posSuccess, pos = getObjectPos(target)
                    
                    if prompt and prompt.Enabled and GameState.rootPart and posSuccess and pos then
                        local destination = pos + Vector3.new(0, 7, 0)
                        
                        task.spawn(function()
                            pcall(function()
                                if Services.tween then
                                    local tween = Services.tween:Create(
                                        GameState.rootPart,
                                        TweenInfo.new(
                                            GameState.config.autoSpeed + math.random(-10, 10) / 100, 
                                            Enum.EasingStyle.Linear
                                        ),
                                        { CFrame = CFrame.new(destination) }
                                    )
                                    
                                    tween:Play()
                                    tween.Completed:Wait()
                                    
                                    task.wait(math.random(50, 150) / 1000)
                                    fireproximityprompt(prompt)
                                    task.wait(math.random(5500, 6500) / 1000)
                                end
                            end)
                        end)
                    end
                end
            end)
            
            -- Intervalo variável entre ciclos
            task.wait(math.random(800, 1200) / 1000)
        end
    end)
end

local originalHeight = nil

AutoTab:AddToggle({
    Name = "Sistema Automático",
    Default = false,
    Callback = function(state)
        task.spawn(function()
            GameState.systemActive = state
            
            if state then
                task.wait(math.random(100, 300) / 1000)
                
                if updatePlayer() and GameState.humanoid then
                    pcall(function()
                        originalHeight = GameState.humanoid.HipHeight
                        GameState.humanoid.HipHeight = (originalHeight or 2) + 2
                    end)
                end
                
                task.wait(math.random(100, 200) / 1000)
                mainLoop()
            else
                if GameState.humanoid and originalHeight ~= nil then
                    task.wait(math.random(100, 200) / 1000)
                    pcall(function()
                        GameState.humanoid.HipHeight = originalHeight
                    end)
                end
            end
        end)
    end
})

-- Limpeza final com proteção
task.spawn(function()
    task.wait(math.random(8, 15))
    
    -- Limpeza gradual para evitar detecção
    refs = nil
    task.wait(1)
    strings = nil
    task.wait(1)
    Services = nil
    task.wait(1)
    
    collectgarbage("collect")
end)
